---
title: Mysql事务
number: 24
url: https://github.com/byronlau/Knowledge-Garden/discussions/24
date: 2023-11-01
createdAt: 2023-11-01T09:58:52Z
lastEditedAt: None
updatedAt: 2023-11-01T09:58:53Z
authors: [byronlau]
categories: 
  - DB
labels: []
filename: Mysql事务.md
---

<section class="output_wrapper" id="output_wrapper_id" style="font-size: 15px; color: rgb(62, 62, 62); line-height: 1.8; word-spacing: 2px; letter-spacing: 2px; font-family: &#39;Helvetica Neue&#39;, Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft YaHei&#39;, Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin-top: 1.7em; margin-bottom: 1.7em;"><span style="color: #3E3E3E; font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 2px; word-spacing: 2px; text-wrap: wrap;">事务的特性：原子性、一致性、隔离性、持久性</span><br style="color: rgb(62, 62, 62); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 2px; word-spacing: 2px; text-wrap: wrap;"/><span style="color: #3E3E3E; font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 2px; word-spacing: 2px; text-wrap: wrap;">多事务同时执行：脏读、幻读、不可重复读</span><br style="color: rgb(62, 62, 62); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 2px; word-spacing: 2px; text-wrap: wrap;"/><span style="color: #3E3E3E; font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 2px; word-spacing: 2px; text-wrap: wrap;">事务的隔离级别：读未提交、读提交、可重复读、串行化</span></p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin-top: 1.7em; margin-bottom: 1.7em;">不同事务隔离级别的区别：</p><ul style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px 0px 0px 32px;" class=" list-paddingleft-2"><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</span></p></li></ul><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin-top: 1.7em; margin-bottom: 1.7em;">其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。<br/></p><figure style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;"><img src="http://img.mgd2008.com/Fugl7DPVqYaibX7kNlqKLwTLameE" alt="" title="" style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;"/><figcaption style="line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;"></figcaption></figure><blockquote style="line-height: inherit; padding: 15px 15px 15px 1rem; font-size: 0.9em; margin: 1em 0px; color: rgb(0, 0, 0); border-left: 5px solid rgb(239, 112, 96); background: rgb(239, 235, 233); overflow: auto; overflow-wrap: normal; word-break: normal;"><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin-top: 0px; margin-bottom: 0px;">我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。</p></blockquote><ul style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px 0px 0px 32px;" class=" list-paddingleft-2"><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A看到。所以， V3 的值也是 2。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</span></p></li><li><p><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</span></p></li></ul><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin-top: 1.7em; margin-bottom: 1.7em;">在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p></section><p><br/></p>
<script src="https://giscus.app/client.js"
    data-repo="byronlau/Knowledge-Garden"
    data-repo-id="R_kgDOKkfaDQ"
    data-mapping="number"
    data-term="24"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async>
</script>
        